---
title: "[Python] 파이썬 문법"
excerpt: "파이썬 기초 문법 정리"

categories:
  - Python

toc: false
toc_sticky: false
 
date: 2023-04-17
last_modified_at: 2023-04-17
---

# 자료형

파이썬에는 정수형, 실수형, 복소수형, 문자열, 리스트, 튜플, 사전 등이 있다.  

## 정수형

정수를 다루는 자료형이다.  
양의 정수, 음의 정수, 0이 포함된다.  
코딩 테스트에서는 주로 정수형을 다룬다.  

```python
a = 1000    # 양의 정수
print(a)

a = -7  # 음의 정수
print(a)

a = 0   # 0
print(a)

a = a + 3
print(a)

a = a -5
print(a)
```

## 실수형

소수점 아래의 데이터를 포함하는 수 자료형이다.  
변수에 소수점을 붙인 수를 대입하면 실수형 변수로 처리된다.  

소수부가 0이거나 정수부가 0인 소수는 0을 생략하고 작성할 수 있다.  
예를 들어 `0.7` 은 `.7` 로 작성할 수 있다.  

```python
a = 157.98
a = -1823.2
a = 5.
a = -.7
```

### 지수 표현 방식

e나 E를 이용한 지수 표현 방식을 이용할 수 있다.  
e나 E 다음에 오는 수는 10의 지수부를 의미한다.  
예를 들어 `1e9` 라고 입력하게 되면, 10의 9제곱이 된다.  

임의의 큰 수를 표현하기 위해 주로 사용하며, 최단 경로 알고리즘에서 도달할 수 없는 노드에 대해 최단 거리를 무한(INF)로 설정하곤 한다.  
이때 가능한 최댓값이 10억 미만이라면 무한(INF)의 값으로 `1e9` 를 이용할 수 있다.  

- 소스 코드  

```python
a = 1e9
print(a)
a = 75.25e1
print(a)
a = 3954e-3
print(a)
```

- 출력  

```
1000000000.0
752.5
3.954
```

### 실수형 더 알아보기

오늘날 컴퓨터는 4바이트 혹은 8바이트의 고정된 크기의 메모리를 할당하기 때문에 실수 정보를 표현하는 정확도에 한계가 있다.  
10진수 체계에서는 0.3 + 0.6 연산이 0.9로 정확히 떨어지더라도, 2진수에서는 0.9를 정확하게 표현할 수 있는 방법이 없다.  
컴퓨터도 마찬가지로 최대한 0.9와 가깝게 표현하지만, 미세한 오차가 발생하게 된다.  

- 소스코드  

```python
a = 0.6 + 0.9
print(a)

if a == 0.9:
    print(True)
else:
    print(False)
```

- 출력

```
0.8999999999999999
False
```

이런 경우 `round()` 함수 사용을 권장한다.  

`round()` 사용법: `round(실수형 값, 반올림 해서 나타낼 자리 수)`  

- 소스코드  

```python
a = round(123.456, 2)
print(a)

a = 0.3 + 0.6
print(round(a, 4))

if round(a, 4) == 0.9:
    print(True)
else:
    print(False)
```

- 출력  

```
123.46
0.9
True
```

## 수 자료형의 연산

사칙연산(+, -, *, /)과 나머지 연산자(%)가 많이 사용된다.  
나누기 연산자(/)를 사용하면 나눠진 결과를 실수형으로 반환한다.  

몫을 얻기 위해 몫 연산자(`//`)를 사용할 수 있다.  

거듭 제곱 연산자(`**`) 등 다양한 연산자가 존재한다.  

# 리스트 자료형

데이터를 연속적으로 담아 처리하기 위한 자료형이다.  
C나 자바에서의 배열(Array) 기능 및 연결 리스트와 유사한 기능을 지원한다.  
리스트 대신 배열 혹은 테이블이라고 부르기도 한다.  

배열을 써야할 때는 리스트를 쓰면 된다.  

- 소스코드

```python
a = [1, 2, 3, 4, 5, 6, 7, 8, 9]

print(a[3])

n = 10
a = [0] * n
print(a)
```

- 출력  

```
[1, 2, 3, 4, 5, 6, 7, 8, 9]
4
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```

## 리스트 인덱싱과 슬라이싱

### 인덱싱

값을 입력하여 특정 원소에 접근하는 것을 인덱싱(Indexing)이라고 한다.  
양의 정수와 음의 정수를 모두 사용할 수 있으며, 음의 정수를 넣으면 거꾸로 탐색한다.  
양의 정수의 경우 0부터, 음의 정수의 경우 -1부터 사용한다.  

### 슬라이싱

연속적인 위치를 갖는 원소들을 가져와야 할 때는 슬라이싱(Slicing)을 이용한다.  
대괄호 안에 콜론(:)을 넣어서 시작 인덱스와 끝 인덱스를 설정할 수 있다.  
끝 인덱스는 실제 인덱스보다 1 크게 설정해야 한다.  

- 소스코드  

```python
a = [1, 2, 3, 4, 5, 6, 7, 8, 9]

print(a[3])

print(a[1:4])
```

- 출력  

```
4
[2, 3, 4]
```

## 리스트 컴프리헨션

리스트를 초기화 하는 방법 중 하나이다.  
대괄호 안에 조건문과 반복문을 적용하여 리스트를 초기화 할 수 있다.  

일반적인 코드보다 짧게 작성하여 구현할 수 있다.  

- 소스코드  

```python
array = [i for i in range(10)]

print(array)

array = [i for i in range(20) if i % 2 == 1]

print(array)

array = [i*i for i in range(1, 10)]

print(array)
```

- 출력  

```
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
[1, 4, 9, 16, 25, 36, 49, 64, 81]
```

2차원 리스트를 초기화 할 때 효과적으로 사용할 수 있다.  
N X M 크기의 2차원 리스트를 한 번에 초기화 할 경우 유용하다.  

```python
array = [[0] * m for _ in range[n]]
# 틀린 경우: array = [[0] * m] * n
```

만약 잘못된 경우로 초기화하면 리스트 안에 포함된 각 리스트가 모두 같은 객체로 인식된다.  

## 언더바 사용

반복을 수행하되 반복을 위한 변수 값을 무시하고자 할 때 언더바(_)를 사용한다.  

## 리스트 관련 기타 메서드

| 함수명 | 사용법 | 설명 |
|---|---|---|
| append() | 변수명.append() | 리스트에 원소 하나 삽입 |
| sort() | 변수명sort() | 오름차순으로 정렬, reverse = True 를 줄 경우 내림차순으로 정렬 |
| reverse() | 변수명.reverse() | 리스트 원소의 순서를 모두 뒤집음 |
| insert() | insert(삽입할 위치 인덱스, 삽입할 값) | 특정 위치에 원소 삽입 |
| count() | 변수명.count(특정 값) | 특정한 값을 가지는 데이터의 개수를 셀 때 사용 |
| remove() | 변수명.remove(특정 값) | 특정 값을 가지는 원소 제거, 여러 개면 하나만 제거 |

# 문자열 자료형

문자열 변수 초기화 시 큰따옴표(") 혹은 작은따옴표 (')를 사용한다.  
문자열 안에 큰따옴표나 작은따옴표를 포함해야 할 경우 이스케이프 문자인 백슬래시(\\)를 사용하면 된다.  

## 문자열 연산

문자열 변수에 덧셈(+)을 이용하면 문자열이 더해져서 연결된다.  
문자열 변수를 양의 정수와 곱하는 경우 문자열이 여러번 더해진다.  
문자열에 대해서도 인덱싱과 슬라이싱이 가능하다.  
다만 특정 인덱스의 값을 변경할 수는 없다.  

- 소스코드

```python
a = "Hello"
b = "World"
print(a + " " + b)

a = "String"
print(a * 3)

a = "ABCEDF"
print(a[2 : 4])
```

- 출력

```
Hello World
StringStringString
CD
```

# 튜플 자료형

리스트와 유사하지만 몇 가지 문법적 차이가 있다.  
한 번 선언된 값을 변경할 수 없고, 리스트는 대괄호([])를 이용하지만 튜플은 소괄호(())를 이용한다.  
리스트에 비해 상대적으로 공간 효율적이다.  

- 소스코드

```python
a = (1, 2, 3, 4, 5, 6, 7, 8, 9)

print(a[3])
print(a[1 : 4])
```

- 출력

```
4
(2, 3, 4)
```

## 사용하면 좋은 경우

최단 경로 알고리즘에서 서로 다른 성질의 데이터를 묶어서 관리해야 할 때 (비용, 노드 번호)의 형태로 자주 사용한다.  
변경이 불가능하므로 해싱(Hashing)의 키 값으로 사용될 수 있다.  
리스트보다 메모리르 효율적으로 사용해야 할 때 쓸 수 있다.  

# 사전 자료형

키(Key)와 값(Value)의 쌍을 데이터로 가지는 자료형이다.  
키와 값의 쌍을 데이터로 가지며, 원하는 변경 불가능한 자료형을 키로 사용할 수 있다.  
해시 테이블을 이용하므로 데이터의 조회 및 수정에 있어서 O(1)의 시간에 처리할 수 있다.  

- 소스코드

```python
data = dict()
data['사과'] = 'Apple'
data['바나나'] = 'Banana'
data['코코넛'] = 'Coconut'

print(data)

if '사과' in data:
    print("'사과'를 키로 가지는 데이터가 존재합니다.")
```

## 관련 메서드

키와 값을 별도로 뽑아내기 위한 메서드를 지원한다.  
키 데이터만 뽑아서 리스트로 이용할 때는 `keys()` 함수를 이용하고, 값 데이터만 뽑아서 리스트로 이용할 때는 `values()` 함수를 이용한다.  

# 집합 자료형

중복을 허용하지 않고 순서가 없다.  
리스트 혹은 문자열을 이용하여 `set()` 함수를 통해 초기화할 수 있다.  
데이터의 조회 및 수정에 있어서 O(1)의 시간에 처리할 수 있다.  

- 소스코드

```python
data = set{[1, 1, 2, 3, 4, 4, 5]}
print(data)

data = {1, 1, 2, 3, 4, 4, 5}
print(data)
```

- 실행 결과

```
{1, 2, 3, 4, 5}
{1, 2, 3, 4, 5}
```

## 집합 자료형의 연산

기본적으로 합집합, 교집합, 차집합 연산 등이 있다.  

- 소스코드

```python
a = set([1, 2, 3, 4, 5])
b = set([3, 4, 5, 6, 7])

print(a | b) # 합집합
print(a & b) # 교집합
print(a - b) # 차집합
```

- 출력

```
{1, 2, 3, 4, 5, 6, 7}
{3, 4, 5}
{1, 2}
```

## 집합 자료형 관련 함수

- 소스코드

```python
data = set([1, 2 ,3])
print(data)

# 새로운 원소 추가
data.add(4)
print(data)

# 새로운 원소 여러 개 추가
data.update([5, 6])
print(data)

# 특정 값을 갖는 원소 삭제
data.remove(3)
print(data)
```

- 출력

```
{1, 2, 3}
{1, 2, 3, 4}
{1, 2, 3, 4, 5, 6}
{1, 2, 4, 5, 6}
```

## 사전 자료형과 집합 자료형의 특징

리스트나 튜플은 순서가 있어 인덱싱을 통해 자료형의 값을 얻을 수 있다.  
그러나 사전 자료형과 집합 자료형은 순서가 없기 때문에 인덱싱으로 값을 얻을 수 없다.  

# 기본 입출력

