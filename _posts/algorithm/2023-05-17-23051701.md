---
title: "[Algorithm] 최단 경로 알고리즘 "
excerpt: "다익스트라와 플로이드 워셜 알고리즘"

categories:
  - Algorithm

toc: false
toc_sticky: false
use_math: true
 
date: 2023-05-17
last_modified_at: 2023-05-17
---

# 최단 경로 문제

한 지점에서 다른 지점까지의 최단 경로, 한 지점에서 다른 모든 지점까지의 최단 경로 등과 같이 최단 경로를 찾아야 하는 다양한 문제 상황이 존재할 수 있다.  

일반적으로 최단 경로 문제에서는 그래프를 활용하여 각 지점은 노드로 표현하고, 연결된 도로는 간선으로 표현한다.  

## 다익스트라 최단 경로 알고리즘

특정 노드에서 출발하여 다른 모든 노드로 가는 최단 경로를 계산한다.  
음의 간선이 없을 때 정상적으로 동작하며, 현실 세계의 길찾기 문제를 해결할 때 사용할 수 있는 알고리즘이다.  

일반적으로 최단 경로 문제는 다이나믹 프로그래밍 문제로 분류되기도 하지만, 다익스트라 최단 경로 알고리즘은 **그리디 알고리즘** 으로 분류된다.  
매 상황에서 가장 비용이 적은 노드를 선택한다.  

### 동작 과정

1. 출발 노드를 설정한다.  
2. 최단 거리 테이블을 초기화한다.  
3. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택한다.  
4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신한다.  
5. 3번과 4번 과정을 반복한다.  

최단 거리 테이블은 각 노드에 대한 현재까지의 최단 거리 정보를 가지고 있으며, 처리 과정에서 더 짧은 경로를 찾으면 정보를 갱신한다.  

### 특징

매 상황에서 방문하지 않은 가장 비용이 적은 노드를 선택하므로 그리디 알고리즘에 속한다.  

각 단계를 거치면서 한 번 방문 처리된 노드의 최단 거리값은 고정되어 바뀌지 않는다.  
따라서 한 단계 당 하나의 노드에 대한 최단 거리를 확실하게 찾을 수 있게 된다.  

### 간단한 구현

방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택하기 위해 매 단계마다 1차원 테이블의 모든 원소를 순차 탐색한다.  

```python
import sys
input = sys.stdin.readline
INF = int(1e9)  # int 최댓값 설정

n, m = map(int, input().split())
start = int(input())

graph = [[] for i in range(n + 1)]  # 그래프에서 각 노드에 연결된 노드에 대한 정보
visited = [False] * (n + 1) # 방문 여부 체크
distance = [INF] * (n + 1)  # 최단 거리 테이블 초기화

for _ in range(m):  # 간선 정보 입력
    a, b, c = map(int, input().split())
    graph[a].append((b, c))

def get_smallest_node():    # 최단 거리가 가장 짧은 노드 인덱스 찾기
    min_value = INF
    index = 0

    for i in range(1, n + 1):
        if distance[i] < min_value and not visited[i]:
            min_value = distance[i]
            index = i

    return index

def dijkstra(start):    # 다익스트라 알고리즘
    distance[start] = 0
    visited[start] = True

    for j in graph[start]:
        distance[j[0]] = j[1]

    for i in range(n - 1):
        now = get_smallest_node()
        visited[now] = True

        for j in graph[now]:
            cost = distance[now] + j[1]

            if cost < distance[j[0]]:
                distance[j[0]] = cost

dijkstra(start)

for i in range(1, n + 1):   # 최단 거리 출력
    if distance[i] == INF:
        print("INFINITY")
    else:
        print(distance[i])
```

### 간단한 구현 방법의 성능

총 $O(V)$ 번에 걸쳐 최단 거리가 짧은 노드를 매번 선형 탐색해야 한다.  
따라서 전체 시간 복잡도는 $O(V^2)$ 이다.  

일반적으로 코딩 테스트 최단 경로 문제에서 전체 노드의 개수가 5,000개 이하라면 사용할 수 있다.  

### 개선된 구현 방법

단계마다 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택하기 위해 힙(Heap) 자료구조를 사용한다.  
현재 가까운 노드를 저장하기 위해 힙 자료구조를 추가적으로 이용하는 것이다.  
현재의 최단 거리가 가장 짧은 노드를 선택해야 하므로 최소 힙을 사용한다.  