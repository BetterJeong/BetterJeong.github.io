---
title: "[밑바닥2] 3장 word2vec"
excerpt: "추론 기반 기법과 신경망, word2vec, CBOW"

categories:
  - NLP

toc: false
toc_sticky: false

date: 2023-12-20
last_modified_at: 2023-12-20
---

# word2vec

## 추론 기반 기법과 신경망

### 통계 기반 기법의 문제점

SVD를 $n \times n$ 행렬에 적용하는 비용은 $O(n^3)$이다.  
따라서 현업에서 다루는 거대 코퍼스에는 SVD를 적용하기 어렵다.  

![batch](/assets/images/23122001/batch.png)  

통계 기반 기법은 1회 처리만으로 단어의 분산 표현을 얻는다.  
신경망을 활용하는 추론 기반 기법에서는 미니배치로 학습한다.  
미니배치 학습에서는 신경망이 소량의 샘플을 반복해서 학습하며 가중치를 갱신한다.  

데이터를 작게 나눠 학습하기 때문에 계산량이 큰 작업에서도 신경망을 학습시킬 수 있다.  

### 추론 기반 기법 개요

![inference](/assets/images/23122001/inference.png)  

추론이란 주변 단어(컨텍스트)가 주어졌을 때 어떤 단어가 들어갈지를 추측하는 작업이다.  
이러한 추론 문제를 풀고 학습하는 것이 추론 기반 기법이 다루는 문제이다.  
추론 문제를 반복해서 풀면서 단어의 출현 패턴을 학습하는 것이다.  

![inference2](/assets/images/23122001/inference2.png)  

신경망(모델)을 통해 맥락 정보를 입력받아 각 단어의 출현 확률을 출력한다.  
코퍼스를 사용해 모델이 올바른 추측을 내놓도록 학습시킨다.  
이렇게 학습 결과로 단어의 분산 표현을 얻는다.  

'단어의 의미는 주변 단어에 의해 형성된다'는 분포 가설에 기초한다.  

### 신경망에서의 단어 처리

단어를 고정 길이의 벡터로 변환해야 하는데, 이때 원 핫 벡터로 변환한다.  
원 핫 벡터는 벡터의 원소 중 하나만 1이고 나머지는 모두 0인 벡터를 말한다.  

"You say goodbye and I say hello." 라는 문장으로 예를 들어보자.  

![one-hot](/assets/images/23122001/one-hot.png)  

총 어휘 수만큼의 원소를 갖는 벡터를 준비하고, 인덱스가 단어 ID와 같은 원소를 1로, 나머지는 0으로 설정한다.  
단어를 고정 길이 벡터로 변환함으로써 신경망의 입력층이 뉴런 수를 고정할 수 있다.  

![neurons](/assets/images/23122001/neurons.png)  

입력층의 뉴런은 총 7개가 된다.  
각 뉴런은 차례로 각 단어에 대응한다.  

![fully-connected-layer](/assets/images/23122001/fully-connected-layer.png)  

원 핫 벡터를 완전연결계층을 통해 변환하는 모습이다.  
각 노드가 이웃 층의 모든 노드와 화살표로 연결되어 있다.  
화살표에는 가중치(매개변수)가 존재하고, 입력층 뉴런과의 가중합이 은닉층 뉴런이 된다.  

여기서 편향은 생략했다.  
편향을 이용하지 않는 완전연결계층은 행렬 곱 계산에 해당한다.  
이 경우 MatMul 계층과 같아진다.  
대부분 딥러닝 프레임워크들은 편향을 이용할지 선택할 수 있도록 한다.  

![bias](/assets/images/23122001/bias.png)  

완전연결계층의 가중치를 $\mathbf{W}$ 행렬로 표현했다.  

이를 파이썬으로 작성하면 아래와 같다.  

```python
import numpy as np

c = np.array([[1, 0, 0, 0, 0, 0, 0]]) # 입력
W = np.random.randn(7, 3) # 가중치
h = np.matmul(c, W) # 중간 노드

print(h)

# [[-0.70012195  0.25204755  -0.79774592]]
```

ID가 0인 단어를 원 핫 벡터로 표현하여 완전연결계층을 통과시켜 변환하는 코드이다.  
편향이 생략되었으므로 `np.matmul()` 로 행렬 곱을 계산했다.  

```python
import sys
sys.path.append('..')
import numpy as np
from common.layers import MatMul

c = np.array([[1, 0, 0, 0, 0, 0, 0]])
W = np.random.randn(7, 3)
layer = MatMul(W)
h = layer.forward(c)

print(h)
# [[-0.70012195  0.25204755  -0.79774592]]
```

앞에서 구현했던 `MatMul` 계층으로 구현한 코드이다.  
`common` 디렉토리에 있는 `MatMul` 계층을 `import` 해서 사용한다.  
`forward()` 메서드를 호출해 순전파를 수행했다.  

## 단순한 word2vec

word2vec에서는 CBOW 모델과 skip-gram 모델이 주로 사용된다.  
여기서는 **CBOW** 모델을 사용한다.  

### CBOW 모델의 추론 처리

CBOW 모델은 컨텍스트로부터 타깃(target)을 추측하는 용도로 사용하며, 활성화 함수를 사용하지 않는 간단한 구성의 신경망이다.  
타깃은 중앙 단어이고, 주변 단어들이 컨텍스트이다.  

CBOW 모델의 입력은 컨텍스트이며, 컨텍스트를 원 핫 벡터로 변환하여 CBOW 모델이 처리할 수 있도록 준비한다.  

![CBOW](/assets/images/23122001/CBOW.png)  

CBOW 모델의 신경망 구조이다.  
입력층이 2개 있고, 은닉층을 거쳐 출력층에 도착한다.  

두 입력층에서 은닉층으로의 변환은 같은 완전연결계층이 처리하고, 은닉층에서 출력층 뉴런으로의 변환은 다른 연결계층이 처리한다.  
입력층의 개수는 컨텍스트에 포함시킬 단어의 수로 결정한다.  
여기서는 컨텍스트에 포함시킬 단어가 2개이므로 입력층이 2개이다.  

은닉층의 뉴런은 입력층의 완전연결계층에 의해 변환된 값이다.  
입력층이 여러개이면 전체를 평균한다.  

출력층의 뉴런은 7개로, 각각의 뉴런이 각 단어에 대응한다.  
출력층 뉴런은 각 단어의 점수를 뜻하고, 값이 높을수록 대응 단어의 출현 확률이 높아진다.  
점수는 확률로 해석되기 전의 값이고, 소프트맥스 함수를 적용해서 확률을 얻을 수 있다.  

완전연결계층의 가중치 $W_{in}$ 은 $7 \times 3$ 행렬이며, 이 가중치의 각 행에는 해당 단어의 분산 표현이 담겨 있다.  
학습을 진행할수록 맥락에서 출현하는 단어를 잘 추측하는 방향으로 표현들이 갱신된다.  

이때, 은닉층의 뉴런 수를 입력층의 뉴런 수보다 적게 해야 한다.  
단어 예측에 필요한 정보를 간결하게 담아야 밀집 벡터 표현을 얻을 수 있다.  
여기서 은닉층의 정보가 인코딩에 해당한다.  
은닉층의 정보로부터 원하는 결과를 얻는 작업을 디코딩이라고 한다.  

![CBOW2](/assets/images/23122001/CBOW2.png)  

CBOW 모델의 앞단에는 2개의 MatMul 계층이 있으며, 출력을 더한 뒤 평균하여 은닉층 뉴런을 구한다.  
은닉층 뉴런에 또 다른 MatMul 계층을 적용하여 점수(score)를 출력한다.  

위에서 언급한 것처럼, 편향을 사용하지 않는 완전연결계층의 처리는 `MatMul` 계층의 순전파와 같다.  

CBOW 모델의 추론 처리를 파이썬으로 구현하면 아래와 같다.  

```python
import sys
sys.path.append('..')
import numpy as np
from common.layers import MatMul

# 샘플 컨텍스트 데이터
c0 二 np.array([[1, 0, 0, 0, 0, 0, 0]])
c1 = np.array([[0, 0, 1, 0, 0, 0, 0]])

# 가중치 초기화
W_in = np.random.randn(7, 3)
W_out = np.random.randn(3, 7)

# 계층 생성
in_layer0 = MatMul(W_in)
in_layer1 = MatMul(W_in)
out_layer = MatMul(W_out)

# 순전파
h0 = in_layer0.forward(c0)
h1 = in_layer1.forward(c1)

h = 0.5 * (h0 + hl)
s = out_layer.forward(h)

print(s)
# [[ 0.30916255 0.45060817 -0.77308656 0.22054131 0.15037278
# -0.93659277 -0.59612048]]
```

가장 먼저 필요한 가중치를 초기화한다.
입력층에서 사용할 `MatMul` 계층을 가중치를 공유하도록 컨텍스트 수만큼 생성한다.
출력층의 `MatMul` 계층은 1개만 생성한다.  

입력층 측의 `MatMul` 계층들의 `forward()` 메서드를 호출하여 중간 데이터를 계산하고, 출력층 측의 `MatMul` 계층을 통과시켜 점수를 구한다.  

### CBOW 모델의 학습

CBOW 모델에서 출력한 점수에 소프트맥스 함수를 적용하면 확률을 얻을 수 있다.  
이 확률은 컨텍스트가 주어졌을 때 중앙에 어떤 단어가 출현하는지를 나타낸다.  

