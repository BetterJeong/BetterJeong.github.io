---
title: "[Mano의 컴퓨터시스템구조] 디지털 논리회로"
excerpt: "디지털 컴퓨터, 논리 게이트, 불 대수, 맵의 간소화, 조합 회로, 플립플롭, 순차 회로"

categories:
  - Computer Architecture

toc: false
toc_sticky: false

date: 2024-11-25
last_modified_at: 2024-11-25
---

> 컴퓨터 구조 스터디를 하며 'Mano의 컴퓨터시스템구조 제3판' 교재를 정리한 글입니다.

# 디지털 논리회로

## 디지털 컴퓨터

### 디지털(digital)

컴퓨터 내부 정보가 제한된 수의 불연속적인 값으로 표시된다는 것이다.  
(* digit: 숫자, 숫자 기호)  

초기의 전자 디지털 컴퓨터들은 십진수를 사용하여 산술 계산을 수행했다.  
여기서 디지털 컴퓨터라는 용어가 생겨났다.  

인간의 논리가 참 또는 거짓, 예 또는 아니오로 이진적이므로, 디지털 시스템들이 두 개의 값만 가지도록 제한되었다.  
이를 이진수(binary)라고 한다.  

### 이진수

하나의 이진 숫자를 비트(bit)라고 부른다.  

디지털 컴퓨터에서의 정보는 비트들의 그룹으로 표현된다.  
비트 그룹은 같은 비트 그룹일지라도 여러가지 다른 의미로 사용될 수 있다.  
때에 따라 영문자나 다른 제어 신호를 나타낼 수 있다.  

2의 거듭제곱을 통해 이진수와 십진수를 서로 변환할 수 있다.  

- 1001011을 십진수로 변환

$$
1 \times 2 ^6 + 1 \times 2 ^3 + 1 \times 2 ^1 + 1 \times 2 ^0 = 75
$$

오른쪽부터 2의 0제곱, 2의 1제곱 순서대로 1 또는 0과 곱하여 합산한다.

### 하드웨어와 소프트웨어

**하드웨어**: 컴퓨터의 모든 전자 부품과 주변 장치를 구성하는 전자기적 부품들이다.  

**소프트웨어**: 컴퓨터의 다양한 정보 처리 작업을 수행하는 명령어와 데이터들로 구성되어 있다.  

컴퓨터의 연속된 명령어들을 프로그램이라고 한다.  

**시스템 소프트웨어**: 운영체제(Operating System)라고 하는 컴퓨터 시스템을 효율적으로 사용하기 위한 목적의 프로그램 집합이다.  

시스템 소프트웨어는 사용자 응용 프로그램과는 다르다.  

예를 들어 특정 목적을 위하여 작성된 고급 언어 프로그램은 응용 프로그램에 속하고, 이 프로그램을 기계어로 바꿔주는 컴파일러는 시스템 프로그램이다.  

컴퓨터 하드웨어는 복잡하므로, 사용자가 복잡한 동작 원리를 알지 못하더라도 사용할 수 있도록 하기 위함이다.  

### 하드웨어

![digital-computer-block](/assets/images/24112501/digital-computer-block.png)  

컴퓨터 하드웨어는 세 가지 부분으로 나뉜다.

- **RAM**  
  - 임의 접근 기억 장치(Random Access Memory)이다.  
  - 명령어와 데이터를 저장하고 있다.  
  - CPU가 이진 정보를 입력하거나 가져올 때 어느 위치에 저장된 데이터든 항상 일정한 시간이 소요된다.  
  - 데이터를 임의의 위치에서 바로 읽거나 쓸 수 있는 메모리이다.  
- **CPU**  
  - 중앙 처리 장치(Center Processing Unit)이다.  
  - 데이터를 조작하는 산술 및 논리 연산 부분, 데이터를 저장하는 여러 개의 레지스터, 명령어를 가져와 수행하는 제어 회로 등이 들어 있다.  
- **IOP**  
  - 입출력 프로세서(Input Output Processor)이다.  
  - 외부와 통신, 데이터 전송을 제어하는 부분이다.  
  - 입출력 장치에는 키보드, 프린터, 터미널, 자기 디스크 장치(HDD) 등이 있다.  

> 하드디스크는 데이터를 읽고 쓰는 과정에서 입출력을 수행하므로, 보조 기억장치이면서 입출력 장치이다.  

### 컴퓨터 하드웨어의 연구 관점

1. **컴퓨터 조직**  
하드웨어 구성품들의 동작 방식과 연결 방식에 관점을 둔다.  
각 구성품들이 제대로 동작하기 위한 조직적 구조를 연구한다.  
2. **컴퓨터 설계**  
컴퓨터 하드웨어를 설계하는 것이다.  
하드웨어 입장에서 컴퓨터를 구현하고, 제시된 컴퓨터 사양에 따라 적절한 하드웨어를 선택하고 연결 방식을 결정하여 시스템을 개발한다.  
3. **컴퓨터 구조**  
사용자의 입장에서 컴퓨터의 구조나 동작에 관점을 둔다.  
정보의 형식, 명령어 집합, 메모리 기법 등을 연구한다.  

## 논리 게이트

컴퓨터에서 이진 정보는 물리량인 전압 신호를 통해 0과 1을 표현한다.  
예를 들어 3v 신호를 1, 0.5v 신호를 0으로 나타낼 수 있다.  

**게이트(gate)**: 이진 정보를 처리하는 논리 회로이다. 입력 논리의 필요 조건을 만족하면 1 또는 0 신호를 만든다.  

![gate](/assets/images/24112501/gate.png)  

왼쪽부터 여러 종류의 게이트의 이름, 기호, 대수 표현식, 진리표이다.  

논리 표현식의 `'` 표시와 기호 표시의 작은 원은 인버터(inverter), 보수(complement)를 의미한다.  

## 불 대수(Boolean Algebra)  

19세기 수학자 George Boole에 의해 개발되었다.  
0, 1 또는 참(True), 거짓(False)를 표현하고 연산에 사용한다.  
이진 변수와 논리 동작을 취급하는 대수이다.  
$A$, $B$, $x$, $y$ 등 문자로 표기한다.  

불 대수는 디지털 회로의 해석과 설계를 쉽게 하기 위해 사용한다.  

변수 사이의 진리표 관계, 논리도의 입출력 관계를 대수 형식으로 표현하고, 더 간단한 회로를 발견하기 위함이다.  

### 주요 연산

1. **AND**(논리곱)  

2. **OR**(논리합)  

3. **NOT**(부정, 보수)  

### 불 대수의 기본 관계  

![bool](/assets/images/24112501/bool.png)  

(1)~(8): 단일 변수 사이의 기본 관계  
(9)~(13): 보통의 대수와 비슷  
(14): 보통 대수 식에서는 적용되지 않음  
(15), (16): De Morgan 정리  
(17): 어떤 변수가 두 번 보수화되면 자기 자신이 됨  

### 드모르간 정리 (De Morgan 정리)

- AND 연산에 대한 부정은 각 항목의 부정을 OR 연산으로 결합한 것과 같다.  

$$
(x+y+z)'=x'y'z'
$$

![nor](/assets/images/24112501/nor.png)  

- OR 연산에 대한 부정은 각 항목의 부정을 AND 연산으로 결합한 것과 같다.  

$$
(xyz)' = x'+y'+z'
$$

![nand](/assets/images/24112501/nand.png)  

### 불 대수가 디지털 회로에 적용되는 예시

![bool2](/assets/images/24112501/bool2.png)  

위의 그림을 보면 회로의 출력은 아래와 같다.  

$$
F = ABC+ABC'+A'C
$$

불 대수를 적용하여 아래와 같이 식을 간소화할 수 있다.  

$$
\begin{align*}
F &= ABC + ABC' + A'C \\
  &= AB(C + C') + A'C \\
  &= AB + A'C
\end{align*}
$$

### 수식의 보수

드모르간 정리를 이용하여 어떠한 수식 F의 보수를 얻을 수 있다.  
수식에서 모든 OR 연산은 AND로, 모든 AND 연산은 OR로 바꾸고, 각 변수를 보수화한다.  

$$
F = AB + C'D' + B'D \\
F' = (A' + B')(C + D)(B + D')
$$

## 맵의 간소화

### 카르노 맵 (Karnaugh map)

[🔗 공부하는 데 참고한 영상 (전기는빠지직 유튜브)](https://youtu.be/IsMRUf_3m6U?si=ocTJN__kqXcgR3ko)  

진리표로 논리 표현식을 얻을 수 있으며, 논리 표현식은 불 대수로 간단하게 만들 수 있다.  
카르노 맵(Karnaugh map)은 불 함수를 간소화할 수 있는 방식이다.  

민텀(minterm): 진리표에서 변수의 각 조합, $n$ 개 변수가 있으면 $2^n$ 개의 민텀이 있게 됨  

아래와 같은 불 함수가 있다고 할 때,

$$
F = x + y'z
$$

진리표와 논리도는 아래와 같다.  

![karnaugh-map.png](/assets/images/24120401/karnaugh-map.png)  

여기서 출력 $F$ 가 1이 되는 민텀을 뽑으면 아래 식과 같다.  

$$
\begin{align*}
F(x, y, z) &= \sum (1, 4, 5, 6, 7) \\
&= x'y'z+xy'z'+xy'z+xyz'+xyz
\end{align*}
$$

$\sum (1, 4, 5, 6, 7)$ 은 진리표의 1, 4, 5, 6, 7번째 민텀의 논리합이다.  
(진리표의 순번은 0부터 시작한다)  

![karnaugh-map2.png](/assets/images/24120401/karnaugh-map2.png)  

카르노 맵은 2변수 카르노 맵, 3변수 카르노 맵, 4변수 카르노 맵이 있다.  
각 칸에 적힌 숫자는 진리표의 민텀 번호를 의미한다.  
논리 표현식의 결과가 1이면 해당하는 민텀 칸에 1을 적고, 0이면 0을 적는다.  

각 변수는 보통 A, B, C, D로 나타내며, 2변수 카르노 맵에서는 행이 A이고 열이 B, 3변수 카르노 맵에서는 행이 A이고, 열이 BC, 4변수 카르노맵에서는 행이 AB이고, 열이 CD이다.  

위 이미지에서는 각 변수가 1이 되는 위치가 `{` 기호로 표시되어 있다.  
바이트 코드 순서는 이진수 순서대로 나타낸 진리표와 다르게 그레이 코드로 작성되어 있다.  
00 01 11 10 처럼 양옆의 비트와 1만 차이나도록 작성된 것이 그레이 코드(gray code)이다.  

![karnaugh-map3.png](/assets/images/24120401/karnaugh-map3.png)  

진리표에 의해 표시되는 불 함수에서 출력이 1인 민텀 구역에 1을 표기한다.  
그리고 인접한 1을 $2^n$ 개수만큼, 즉 2개, 4개, 8개씩 가능한 크게 묶는다.  
위 그림처럼 양 옆으로 떨어져 있어 보이는 것도 함께 묶는다.  

묶인 그룹에서는 각 민텀이 가진 변수 중에서 중첩된 변수만 남기고 지우면 된다.  
예를 들어, 3번째 민텀과 7번째 민텀 $A'BC$ (011)와 $ABC$ (111)를 보면, $A$ 는 $A'$ (0)와 $A$ (1)로 서로 다르므로 지운다.  
$B$ (1)와 $C$ (1)는 동일하므로 남겨두고, 이 그룹의 결과는 $BC$가 된다.  
이런 방식으로 모든 그룹을 계산하여 논리합(OR)을 취한다.  

![karnaugh-map4.png](/assets/images/24120401/karnaugh-map4.png)  

3변수 카르노 맵에서는 그림 1-9와 같이 양 옆에 있는 민텀도 이어져 있다고 치므로 묶을 수 있다.  
4변수 카르노 맵에서는 그림 1-10과 같이 상하좌우 모서리를 포함하여 끝쪽에 있는 민텀도 이어져 있다고 치므로 묶을 수 있다.  

### 논리합의 논리곱

앞에서 계산한 방식은 논리곱의 논리합(sum of products) 방식이다.  
그룹을 묶어 AND 연산 후 각 그룹을 OR 연산한다.  

경우에 따라 논리합의 논리곱(product of sums) 방식을 사용할 수도 있다.  
이 방식을 사용할 때는 전과 반대로 출력이 0인 민텀 구역에 0을 표기하고 가능한 크게 묶는다.  
결과물은 $F'$ 이 되므로, 드모르간 정리에 의해 $ F = (F')' $ 를 얻을 수 있다.  

### Don't Care 조건

1을 표기하는 논리곱의 논리합, 0을 표기하는 논리합의 논리곱 둘 중 어느 방식이든 민텀이 1이거나 0이거나 관계 없는 don't care 를 가지는 경우가 있다.  
최적의 간소화를 위해 필요할 경우 X로 표기하여 이를 1로 보거나 0으로 보도록 하여 함께 묶을 수 있다.  

$$
F(A, B, C)= \sum (0, 2, 6) \\
d(A, B, C) = \sum (1, 3, 5)
$$

F라는 불 함수가 있을 때, $d(A, B, C)$ 는 don't care 조건이다.  

![karnaugh-map5.png](/assets/images/24120401/karnaugh-map5.png)  

don't care 조건을 전부 0으로 생각하여 묶으면 $ F = A'C' + BC' $ 로 간소화되고, 1로 보고 네 개의 민텀을 크게 묶는다면 $ F = A' + BC' $ 로 간소화할 수 있다.  

## 조합 회로

현재 입력 값이 주어지면 이전 입력과 관계 없이 출력 값이 바로 나오는 회로이다.  

### 반가산기

![half-adder.png](/assets/images/24120401/half-adder.png)  

비트 두 개를 가산하는 조합회로이다.  
위 그림은 두 개의 비트를 $x$ , $y$ 라고 할 때의 진리표이다.  
$c$ 는 carry로 $x$ 와 $y$ 의 AND 연산과 같고, $s$ 는 합으로 $x$ 와 $y$ 의 XOR 연산과 같다.  

### 전가산기

반가산기 두 개로 전가산기가 구성되며, 비트 두개와 밑의 자리로부터 올라오는 carry를 고려하여 비트 세 개를 가산한다.  

![full-adder.png](/assets/images/24120401/full-adder.png)  
![full-adder2.png](/assets/images/24120401/full-adder2.png)  

$z$ 는 밑의 자리에서 올라오는 캐리이고, $C$ 는 다음 자리로 올라가는 캐리이다.  
$S$ 는 $x$ , $y$ , $z$ 의 XOR 연산이다.  
$C$ 는 $x$ , $y$ 의 XOR 연산 후 $z$ 와 AND 연산한 뒤 $x$ 와 $y$ 의 AND 연산 값을 OR 연산한 것과 같다.  

## 플립플롭

모든 디지털 시스템은 조합 회로를 가지고 있지만, 순차회로로 구현되는 저장요소가 필요하다.  
플립플롭은 1비트 데이터를 저장하는 이진 셀(cell)이다.  
입력 펄스가 상태 변환을 일으키기 전까지 이진 상태를 그대로 유지한다.  

### 순차회로

입력 신호뿐만 아니라 현재 상태도 고려하여 출력이 결정되는 회로이다.  
대부분의 순차 회로는 동기형(synchronous) 회로로, 클럭 펄스(clock pulse)를 기준으로 작동한다.  
동기형 회로는 클럭의 타이밍 문제(clock skew 등)로 인해 불안정해질 가능성이 있다.  

클럭 신호: 주기적인 전기 신호로 디지털 회로의 동작 시간적으로 제어  
동기화: 클럭 신호를 기준으로 회로 내 모든 구성 요소가 동시에 상태를 변경하거나 동작하도록 하는 것  

### $SR$ 플립플롭

![sr.png](/assets/images/24120401/sr.png)  

$S$(set), $R$(reset), $C$(clock) 세 개의 입력과 하나의 출력 $Q$를 가지고 있다.  
$C$의 화살표 기호는 동적입력(dynamic input)으로, 플립플롭이 입력 클럭 신호의 상승 변이에서 동작한다는 의미이다.  

$C$에 신호가 들어오지 않을 경우, $S$나 $R$ 입력의 값에 관계없이 출력은 변하지 않는다.  
클럭 신호가 0에서 1로 변하면 $S=1$이고 $R=0$이면 출력 $Q$는 1, $S=0$이고 $R=1$이면 출력 $Q$는 0이 된다.  
$S$와 $R$이 모두 0일 때 클럭 입력이 변하면 출력은 변화가 없다.  

$S$와 $R$이 모두 1인 경우 출력값을 예상할 수 없으므로 회로 설계에서 피해야 한다.  

### $D$ 플립플롭

![d.png](/assets/images/24120401/d.png)  

$SR$ 플립플롭에서 발전된 형태로, $S$와 $R$ 입력을 인버터로 연결하고 $D$ 기호를 붙인 것이다.  
$D$ 입력이 0에서 1로 클럭 변이가 발생할 때 출력 $Q$에 전달된다.  

$$
Q(t+1) = D
$$

### $JK$ 플립플롭 

![jk.png](/assets/images/24120401/jk.png)  

$SR$ 플립플롭의 한계를 보완한 플립플롭이다.  
입력의 $K$와 $K$ 는 각각 $SR$ 플립플롭의 $S$와 $R$에 해당한다.  
$J=K=1$일 때 클럭 펄스는 플립플롭의 출력을 보수로 만든다.  

### $T$ 플립플롭

![t.png](/assets/images/24120401/t.png)  

토글(Toggle) 동작을 수행하는 플립플롭이다.  
입력 신호로 $T$ 하나만 가진다.  
$T=0$인 경우 상태 변화가 없고, $T=1$인 경우 상태는 보수로 된다.  

$$
Q(t+1)=Q(t) \oplus T
$$

### 모서리-변이형 플립플롭

![edge-triggered.png](/assets/images/24120401/edge-triggered.png)  

클럭 펄스의 변이가 발생할 때만 입력 데이터를 받아들이고 출력 상태를 변경한다.  
클럭 신호가 상승하거나 하강할 때만 작동한다.  

셋업 시간(setup time)과 홀드 시간(hold time)이 필요하다.  
셋업 시간: 입력 값이 클럭 신호의 변이가 발생하기 전에 안정된 상태로 유지되어야 하는 최소 시간  
홀드 시간: 클럭 신호 변이 이후에도 입력 값이 안정된 상태로 유지되어야 하는 최소 시간  

### 여기표

![excitation.png](/assets/images/24120401/excitation.png)  

여기표는 플립플롭에서 현재 상태와 다음 상태를 알 때, 플립플롭에 어떤 입력을 넣어야 하는가를 표로 만든 것이다.  