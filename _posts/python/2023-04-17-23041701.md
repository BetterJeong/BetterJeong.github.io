---
title: "[Python] 파이썬 문법"
excerpt: "파이썬 기초 문법 정리"

categories:
  - Python

toc: false
toc_sticky: false
 
date: 2023-04-17
last_modified_at: 2023-05-03
---

# 자료형

파이썬에는 정수형, 실수형, 복소수형, 문자열, 리스트, 튜플, 사전 등이 있다.  

## 정수형

정수를 다루는 자료형이다.  
양의 정수, 음의 정수, 0이 포함된다.  
코딩 테스트에서는 주로 정수형을 다룬다.  

```python
a = 1000    # 양의 정수
print(a)

a = -7  # 음의 정수
print(a)

a = 0   # 0
print(a)

a = a + 3
print(a)

a = a -5
print(a)
```

## 실수형

소수점 아래의 데이터를 포함하는 수 자료형이다.  
변수에 소수점을 붙인 수를 대입하면 실수형 변수로 처리된다.  

소수부가 0이거나 정수부가 0인 소수는 0을 생략하고 작성할 수 있다.  
예를 들어 `0.7` 은 `.7` 로 작성할 수 있다.  

```python
a = 157.98
a = -1823.2
a = 5.
a = -.7
```

### 지수 표현 방식

e나 E를 이용한 지수 표현 방식을 이용할 수 있다.  
e나 E 다음에 오는 수는 10의 지수부를 의미한다.  
예를 들어 `1e9` 라고 입력하게 되면, 10의 9제곱이 된다.  

임의의 큰 수를 표현하기 위해 주로 사용하며, 최단 경로 알고리즘에서 도달할 수 없는 노드에 대해 최단 거리를 무한(INF)로 설정하곤 한다.  
이때 가능한 최댓값이 10억 미만이라면 무한(INF)의 값으로 `1e9` 를 이용할 수 있다.  

- 소스 코드  

```python
a = 1e9
print(a)
a = 75.25e1
print(a)
a = 3954e-3
print(a)
```

- 출력  

```
1000000000.0
752.5
3.954
```

### 실수형 더 알아보기

오늘날 컴퓨터는 4바이트 혹은 8바이트의 고정된 크기의 메모리를 할당하기 때문에 실수 정보를 표현하는 정확도에 한계가 있다.  
10진수 체계에서는 0.3 + 0.6 연산이 0.9로 정확히 떨어지더라도, 2진수에서는 0.9를 정확하게 표현할 수 있는 방법이 없다.  
컴퓨터도 마찬가지로 최대한 0.9와 가깝게 표현하지만, 미세한 오차가 발생하게 된다.  

- 소스코드  

```python
a = 0.6 + 0.9
print(a)

if a == 0.9:
    print(True)
else:
    print(False)
```

- 출력

```
0.8999999999999999
False
```

이런 경우 `round()` 함수 사용을 권장한다.  

`round()` 사용법: `round(실수형 값, 반올림 해서 나타낼 자리 수)`  

- 소스코드  

```python
a = round(123.456, 2)
print(a)

a = 0.3 + 0.6
print(round(a, 4))

if round(a, 4) == 0.9:
    print(True)
else:
    print(False)
```

- 출력  

```
123.46
0.9
True
```

## 수 자료형의 연산

사칙연산(+, -, *, /)과 나머지 연산자(%)가 많이 사용된다.  
나누기 연산자(/)를 사용하면 나눠진 결과를 실수형으로 반환한다.  

몫을 얻기 위해 몫 연산자(`//`)를 사용할 수 있다.  

거듭 제곱 연산자(`**`) 등 다양한 연산자가 존재한다.  

# 리스트 자료형

데이터를 연속적으로 담아 처리하기 위한 자료형이다.  
C나 자바에서의 배열(Array) 기능 및 연결 리스트와 유사한 기능을 지원한다.  
리스트 대신 배열 혹은 테이블이라고 부르기도 한다.  

배열을 써야할 때는 리스트를 쓰면 된다.  

- 소스코드

```python
a = [1, 2, 3, 4, 5, 6, 7, 8, 9]

print(a[3])

n = 10
a = [0] * n
print(a)
```

- 출력  

```
[1, 2, 3, 4, 5, 6, 7, 8, 9]
4
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```

## 리스트 인덱싱과 슬라이싱

### 인덱싱

값을 입력하여 특정 원소에 접근하는 것을 인덱싱(Indexing)이라고 한다.  
양의 정수와 음의 정수를 모두 사용할 수 있으며, 음의 정수를 넣으면 거꾸로 탐색한다.  
양의 정수의 경우 0부터, 음의 정수의 경우 -1부터 사용한다.  

### 슬라이싱

연속적인 위치를 갖는 원소들을 가져와야 할 때는 슬라이싱(Slicing)을 이용한다.  
대괄호 안에 콜론(:)을 넣어서 시작 인덱스와 끝 인덱스를 설정할 수 있다.  
끝 인덱스는 실제 인덱스보다 1 크게 설정해야 한다.  

- 소스코드  

```python
a = [1, 2, 3, 4, 5, 6, 7, 8, 9]

print(a[3])

print(a[1:4])
```

- 출력  

```
4
[2, 3, 4]
```

## 리스트 컴프리헨션

리스트를 초기화 하는 방법 중 하나이다.  
대괄호 안에 조건문과 반복문을 적용하여 리스트를 초기화 할 수 있다.  

일반적인 코드보다 짧게 작성하여 구현할 수 있다.  

- 소스코드  

```python
array = [i for i in range(10)]

print(array)

array = [i for i in range(20) if i % 2 == 1]

print(array)

array = [i*i for i in range(1, 10)]

print(array)
```

- 출력  

```
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
[1, 4, 9, 16, 25, 36, 49, 64, 81]
```

2차원 리스트를 초기화 할 때 효과적으로 사용할 수 있다.  
N X M 크기의 2차원 리스트를 한 번에 초기화 할 경우 유용하다.  

```python
array = [[0] * m for _ in range[n]]
# 틀린 경우: array = [[0] * m] * n
```

만약 잘못된 경우로 초기화하면 리스트 안에 포함된 각 리스트가 모두 같은 객체로 인식된다.  

## 언더바 사용

반복을 수행하되 반복을 위한 변수 값을 무시하고자 할 때 언더바(_)를 사용한다.  

## 리스트 관련 기타 메서드

| 함수명 | 사용법 | 설명 |
|---|---|---|
| append() | 변수명.append() | 리스트에 원소 하나 삽입 |
| sort() | 변수명sort() | 오름차순으로 정렬, reverse = True 를 줄 경우 내림차순으로 정렬 |
| reverse() | 변수명.reverse() | 리스트 원소의 순서를 모두 뒤집음 |
| insert() | insert(삽입할 위치 인덱스, 삽입할 값) | 특정 위치에 원소 삽입 |
| count() | 변수명.count(특정 값) | 특정한 값을 가지는 데이터의 개수를 셀 때 사용 |
| remove() | 변수명.remove(특정 값) | 특정 값을 가지는 원소 제거, 여러 개면 하나만 제거 |

# 문자열 자료형

문자열 변수 초기화 시 큰따옴표(") 혹은 작은따옴표 (')를 사용한다.  
문자열 안에 큰따옴표나 작은따옴표를 포함해야 할 경우 이스케이프 문자인 백슬래시(\\)를 사용하면 된다.  

## 문자열 연산

문자열 변수에 덧셈(+)을 이용하면 문자열이 더해져서 연결된다.  
문자열 변수를 양의 정수와 곱하는 경우 문자열이 여러번 더해진다.  
문자열에 대해서도 인덱싱과 슬라이싱이 가능하다.  
다만 특정 인덱스의 값을 변경할 수는 없다.  

- 소스코드

```python
a = "Hello"
b = "World"
print(a + " " + b)

a = "String"
print(a * 3)

a = "ABCEDF"
print(a[2 : 4])
```

- 출력

```
Hello World
StringStringString
CD
```

# 튜플 자료형

리스트와 유사하지만 몇 가지 문법적 차이가 있다.  
한 번 선언된 값을 변경할 수 없고, 리스트는 대괄호([])를 이용하지만 튜플은 소괄호(())를 이용한다.  
리스트에 비해 상대적으로 공간 효율적이다.  

- 소스코드

```python
a = (1, 2, 3, 4, 5, 6, 7, 8, 9)

print(a[3])
print(a[1 : 4])
```

- 출력

```
4
(2, 3, 4)
```

## 사용하면 좋은 경우

최단 경로 알고리즘에서 서로 다른 성질의 데이터를 묶어서 관리해야 할 때 (비용, 노드 번호)의 형태로 자주 사용한다.  
변경이 불가능하므로 해싱(Hashing)의 키 값으로 사용될 수 있다.  
리스트보다 메모리르 효율적으로 사용해야 할 때 쓸 수 있다.  

# 사전 자료형

키(Key)와 값(Value)의 쌍을 데이터로 가지는 자료형이다.  
키와 값의 쌍을 데이터로 가지며, 원하는 변경 불가능한 자료형을 키로 사용할 수 있다.  
해시 테이블을 이용하므로 데이터의 조회 및 수정에 있어서 O(1)의 시간에 처리할 수 있다.  

- 소스코드

```python
data = dict()
data['사과'] = 'Apple'
data['바나나'] = 'Banana'
data['코코넛'] = 'Coconut'

print(data)

if '사과' in data:
    print("'사과'를 키로 가지는 데이터가 존재합니다.")
```

## 관련 메서드

키와 값을 별도로 뽑아내기 위한 메서드를 지원한다.  
키 데이터만 뽑아서 리스트로 이용할 때는 `keys()` 함수를 이용하고, 값 데이터만 뽑아서 리스트로 이용할 때는 `values()` 함수를 이용한다.  

# 집합 자료형

중복을 허용하지 않고 순서가 없다.  
리스트 혹은 문자열을 이용하여 `set()` 함수를 통해 초기화할 수 있다.  
데이터의 조회 및 수정에 있어서 O(1)의 시간에 처리할 수 있다.  

- 소스코드

```python
data = set{[1, 1, 2, 3, 4, 4, 5]}
print(data)

data = {1, 1, 2, 3, 4, 4, 5}
print(data)
```

- 실행 결과

```
{1, 2, 3, 4, 5}
{1, 2, 3, 4, 5}
```

## 집합 자료형의 연산

기본적으로 합집합, 교집합, 차집합 연산 등이 있다.  

- 소스코드

```python
a = set([1, 2, 3, 4, 5])
b = set([3, 4, 5, 6, 7])

print(a | b) # 합집합
print(a & b) # 교집합
print(a - b) # 차집합
```

- 출력

```
{1, 2, 3, 4, 5, 6, 7}
{3, 4, 5}
{1, 2}
```

## 집합 자료형 관련 함수

- 소스코드

```python
data = set([1, 2 ,3])
print(data)

# 새로운 원소 추가
data.add(4)
print(data)

# 새로운 원소 여러 개 추가
data.update([5, 6])
print(data)

# 특정 값을 갖는 원소 삭제
data.remove(3)
print(data)
```

- 출력

```
{1, 2, 3}
{1, 2, 3, 4}
{1, 2, 3, 4, 5, 6}
{1, 2, 4, 5, 6}
```

## 사전 자료형과 집합 자료형의 특징

리스트나 튜플은 순서가 있어 인덱싱을 통해 자료형의 값을 얻을 수 있다.  
그러나 사전 자료형과 집합 자료형은 순서가 없기 때문에 인덱싱으로 값을 얻을 수 없다.  

# 기본 입출력

## 입력

`input()` 함수는 한 줄의 문자열을 입력 받는 함수이다.  
`map()` 함수는 리스트의 모든 원소에 각각 특정한 함수를 적용할 때 사용한다.  

```python
# 공백을 기준으로 구분된 데이터 입력 받기
list(map(int, input().split()))

# 공백을 기준으로 구분된 데이터의 개수가 많지 않을 때
a, b, c = map(int, input().split())
```

### 빠르게 입력 받기

입력을 최대한 빠르게 받아야 하는 경우 `sys` 라이브러리에 정의되어 있는 `sys.stdin.readline()` 메서드를 이용한다.  
입력 후 엔터(Enter)가 줄 바꿈 기호로 입력되므로 `rstrip()` 메서드를 함께 사용한다.  

```python
import sys

data = sys.stdin.readline().rstrip()
print(data)
```

## 출력

기본 출력은 `print()` 함수를 이용한다.  
각 변수를 콤마(,)를 이용하여 띄어쓰기로 구분해 출력할 수 있다.  
`print()` 함수는 출력 이후 줄 바꿈을 수행한다.  
줄 바꿈을 원치 않을 경우 `end` 속성을 이용할 수 있다.  

- 소스코드

```python
a = 1
b = 2
print(a, b)
print(7, end=" ")
print(8, end=" ")

answer = 7
print(" 정답은 " + str(answer) + "입니다.")
```

- 출력

```
1 2
7 8 정답은 7입니다.
```

### f-string

파이썬 3.6부터 사용 가능하다.  
문자열 앞에 접두사 `f`를 붙여 사용한다.  
중괄호 안에 변수명을 기입하여 문자열과 정수를 함께 넣을 수 있다.  

```python
answer = 7
print(f"정답은 {answer}입니다.")
```

# 조건문

프로그램의 흐름을 제어하는 문법이다.  
조건에 따라 프로그램의 로직을 설정할 수 있다.  
대부분의 프로그램에서 필수적으로 사용된다.  

기본적인 형태는 if ~ elif ~ else 이며, elif 혹은 else 부분은 경우에 따라 사용하지 않아도 된다.  

- 소스코드

```python
x = 15

if x >= 10:
    print("x >= 10")

if x >= 0:
    print("x >= 0")

if x >= 30:
    print("x >= 30")
```

- 출력

```
x >= 10
x >= 0
```

## 비교 연산자

특정 두 값을 비교할 때 이용한다.  
대입 연산자(=)와 같음 연산자(==)는 차이가 있다.  

| 비교 연산자 | 설명 |
|---|---|
| X == Y | X와 Y가 같을 때 참 |
| X != Y | X와 Y가 서로 다를 때 참 |
| X > Y | X가 Y보다 클 때 참 |
| X < Y | X가 Y보다 작을 때 참 |
| X >= Y | X가 Y보다 크거나 같을 때 참 |
| X <= Y | X가 Y보다 작거나 같을 때 참 |

## 논리 연산자

논리 값 사이의 연산 수행 시 사용한다.  

| 논리 연산자 | 설명 |
|---|---|
| X and Y | X와 Y가 모두 참일 때 참 |
| X or Y | X와 Y 중에 하나만 참이어도 참 |
| not X | X가 거짓일 때 참 |

## 기타 연산자

다수의 데이터를 담는 자료형을 위한 in 연산자와 not in 연산자가 제공된다.  
`x in 리스트` 연산자는 리스트 안에 x가 들어 있을 때 참이고, `x not in 리스트` 연산자는 리스트 안에 x가 들어 있지 않을 때 참이다.  
리스트, 튜플, 문자열, 딕셔너리 모두에서 사용이 가능하다.  

## 들여쓰기

코드의 블록(Block)을 들여쓰기(Indent)로 지정한다.  

탭을 사용하는 쪽과 공백 문자(space)를 여러번 사용하는 쪽의 두 진영이 있다.  
파이썬 스타일 가이드라인에서는 4개의 공백 문자를 사용하는 것을 표준으로 설정한다.  

## pass 키워드

아무것도 처리하고 싶지 않을 때, 디버깅 과정에서 조건문 형태만 일단 만들어 놓고 처리하는 부분은 비워놓고 나중에 작성하고 싶은 경우 `pass` 키워드를 사용한다.  

## 조건문의 간소화

실행될 소스코드가 한 줄일 경우 굳이 줄바꿈을 하지 않아도 된다.  

조건부 표현식은 if ~ else문을 한줄에 작성할 수 있도록 해준다.  

```python
score = 85
result = "Success" if score >= 80 else "Fail"

print(result)
```

## 조건문 내에서의 부등식

조건문 안에서 수학의 부등식을 그대로 사용할 수 있다.  
`x > 0 and x < 20`과 `0 < x < 20` 은 같다.  

# 반복문

특정 소스코드를 반복적으로 실행하고자 할 때 사용한다.  
while문과 for문 중 어떤 것을 사용해도 상관이 없으나 코딩 테스트에서는 for문이 간결한 경우가 많다.  

## while문

- 소스코드

```python
i = 1
result = 0

while i <= 9:
    result += i
    i += 1

print(result)
```

- 출력

```
45
```

## for문

특정 변수를 이용하여 `in` 뒤에 오는 데이터(리스트, 튜플 등)에 포함되어 있는 원소를 첫 번째 인덱스부터 차례로 하나씩 방문한다.  

- 소스코드

```python
array = [9, 8, 7, 6, 5]

for x in array:
    print(x)
```

- 출력

```
9
8
7
6
5
```

### 연속적인 값 순회

for문에서 연속적인 값을 차례로 순회할 때 `range()` 를 주로 사용한다.  
`range(시작값, 끝값+1)` 형태로 사용하며, 인자를 하나만 넣으면 자동으로 시작 값이 0이 된다.  

- 소스코드

```python
result = 0

for i in range(1, 10):
    result += i

print(result)

```

- 출력

```
45
```

## 반복문에서 사용하는 키워드

반복문에서 남은 코드의 실행을 건너뛰고, 다음 반복을 진행하고자 할 때 `continue` 키워드를 사용한다.  
반복문을 즉시 탈출하고자 할 때 `break` 키워드를 사용한다.  

# 함수

특정 작업을 하나의 단위로 묶어 놓은 것을 의미한다.  
불필요한 소스코드의 반복을 줄일 수 있다.  

파이썬에서의 함수는 내장 함수와 사용자 정의 함수로 나뉜다.  

내장 함수는 파이썬이 기본적으로 제공하는 함수이다.  
일반적으로 프로그램 개발 전반에서 자주 사용되는 기능을 미리 파이썬이 준비해 놓고 개발자들이 필요할 때마다 쓸 수 있도록 제공한다.  
`input()` , `print()` 와 같은 함수들이다.

사용자 정의 함수는 개발자가 직접 정의하여 사용할 수 있는 함수이다.  

## 함수 정의하기

프로그램에는 똑같은 코드가 반복적으로 사용되어야 할 때가 많다.  
함수를 사용하면 소스코드의 길이를 줄일 수 있다.  

매개변수란 함수 내부에서 사용할 변수를 말한다.  
반환 값은 함수에서 처리된 결과를 반환할 때 `return` 키워드와 함께 사용한다.  

```python
def 함수명(매개변수):
    실행할 소스코드
    return 반환 값
```

### 여러 개의 반환 값

여러 개의 반환 값을 가질 수 있다.  
콤마(,)를 이용해 반환 값을 **패킹** 한다.  

## 람다 표현식

람다를 이용해 함수를 간단하게 작성할 수 있다.  

- 소스코드

```python
print((lambda a, b:a + b)(3, 7))
```

### 람다 예시

- 소스코드

```python
array = [('홍길동', 50), ('이순신', 32), ('아무개', 74)]

def my_key(x):
    return x[1]

print(sorted(array, key=my_key))
print(sorted(array, key=lambda x: x[1]))
```

- 출력

```
[('이순신', 32), ('홍길동', 50), ('아무개', 74)]
[('이순신', 32), ('홍길동', 50), ('아무개', 74)]
```

# 유용한 표준 라이브러리

### 내장 함수

기본 입출력 함수부터 정렬 함수까지 기본적인 함수들을 제공한다.  
`import` 구문 없이 사용 가능하다.  

### itertools

반복되는 형태의 데이터를 처리하기 위한 기능을 제공한다.  
순열과 조합 라이브러리가 포함되어 있다.  
모든 경우의 수를 고려해야 하는 경우에 효과적으로 사용할 수 있다.  

### heapq

힙 자료구조를 제공한다.  
우선순위 큐 기능을 구현하기 위해 사용된다.  
다익스트라와 같은 최단 경로 알고리즘에서 많이 활용된다.  

### bisect

이진 탐색 기능을 제공한다.  
기본적인 이진 탐색이 필요할 경우 효과적이다.  

### collections

덱, 카운터 등의 유용한 자료구조를 포함한다.  

### math

필수적인 수학적 기능을 제공한다.  